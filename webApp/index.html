<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChronoSense</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/luxon/2.3.1/luxon.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-adapter-luxon/1.2.0/chartjs-adapter-luxon.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <style>
        :root {
            --primary-color: #3182ce;
            --primary-light: #ebf8ff;
            --secondary-color: #38b2ac;
            --panel-bg: #f9fafb;
            --panel-border: #e2e8f0;
            --header-bg: #ff3b30;
            --header-text: #ffffff;
            --success-color: #38a169;
            --danger-color: #e53e3e;
            --connect-btn: #0a84ff;
            --text-color: #2d3748;
            --text-muted: #718096;
        }
        
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 10px;
            background-color: #f5f5f5;
            color: var(--text-color);
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 20px;
        }
        
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 10px 15px;
            background-color: var(--header-bg);
            border-radius: 8px;
            color: var(--header-text);
        }
        
        .logo-title {
            display: flex;
            align-items: center;
        }
        
        .logo {
            width: 62.5px; /* 25% larger than 50px */
            height: 62.5px; /* 25% larger than 50px */
            margin-right: 15px;
        }
        
        .title-container {
            display: flex;
            flex-direction: column;
        }
        
        h1 {
            color: var(--header-text);
            margin: 0;
            font-size: 26px;
        }
        
        .instance-subtitle {
            color: rgba(255, 255, 255, 0.85);
            font-size: 14px;
            margin-top: 4px;
            font-weight: normal;
        }
        
        .header-controls {
            display: flex;
            gap: 20px;
            align-items: center;
            height: 40px;
        }
        
        .control-box {
            height: 100%;
            display: flex;
            align-items: center;
        }
        
        .export-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            background-color: rgba(255, 255, 255, 0.15);
            padding: 0 12px;
            border-radius: 6px;
            height: 100%;
        }
        
        .panel {
            background-color: var(--panel-bg);
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
            padding: 18px;
            margin-bottom: 20px;
            border: 1px solid var(--panel-border);
        }
        
        .panel-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
            color: var(--primary-color);
            padding-bottom: 8px;
            border-bottom: 2px solid var(--panel-border);
        }
        
        .flex-container {
            display: flex;
            gap: 20px;
        }
        
        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            height: 36px;
        }
        
        button:hover {
            background-color: #2c5282;
        }
        
        button:disabled {
            background-color: var(--text-muted);
            cursor: not-allowed;
        }
        
        #connectButton {
            background-color: var(--connect-btn);
            min-width: 110px;
            border-radius: 6px;
            font-weight: 500;
        }
        
        #connectButton:hover {
            background-color: #0066cc;
        }
        
        #exportButton {
            background-color: rgba(255, 255, 255, 0.2);
            min-width: 90px;
        }
        
        #exportButton:hover {
            background-color: rgba(255, 255, 255, 0.3);
        }
        
        #exportButton:disabled {
            background-color: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.5);
        }
        
        /* Active export button with better visibility */
        #exportButton:not(:disabled) {
            background-color: rgba(255, 255, 255, 0.85);
            color: var(--header-bg);
            font-weight: 500;
        }
        
        #exportButton:not(:disabled):hover {
            background-color: white;
        }
        
        /* Auto export input states */
        #autoExport {
            width: 40px;
            text-align: center;
            opacity: 0.6;
            transition: opacity 0.3s, background-color 0.3s;
        }
        
        #autoExport:disabled {
            opacity: 0.4;
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        #autoExport:not(:disabled) {
            opacity: 1;
            background-color: rgba(255, 255, 255, 0.85);
            color: var(--text-color);
        }
        
        .settings-row.disabled {
            opacity: 0.5;
        }
        
        .settings-row.enabled {
            opacity: 1;
        }
        
        .connection-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            background-color: #4cd964;
            display: none;
        }
        
        .connection-indicator.active {
            display: inline-block;
        }
        
        #aboutButton {
            background-color: rgba(240, 240, 240, 0.9);
            width: 36px;
            height: 36px;
            padding: 0;
            justify-content: center;
            border-radius: 50%;
            flex-shrink: 0;
            color: var(--header-bg);
        }
        
        #aboutButton:hover {
            background-color: white;
        }
        
        #dataTable {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        
        #dataTable th, #dataTable td {
            border: 1px solid var(--panel-border);
            padding: 8px;
            text-align: left;
        }
        
        #dataTable th {
            background-color: var(--primary-light);
            position: sticky;
            top: 0;
            color: var(--primary-color);
        }
        
        /* Editable column header styling */
        #dataTable th.editable {
            cursor: pointer;
            position: relative;
        }
        
        #dataTable th.editable:hover {
            background-color: #dbeafe;
        }
        
        #dataTable th.editable:after {
            content: "âœŽ";
            position: absolute;
            right: 5px;
            color: var(--primary-color);
            font-size: 12px;
            opacity: 0.6;
        }
        
        #dataTable th.editing {
            padding: 0;
        }
        
        #dataTable th.editing input {
            width: 100%;
            box-sizing: border-box;
            padding: 8px;
            border: none;
            outline: 2px solid var(--primary-color);
            background-color: white;
            font-weight: bold;
            color: var(--primary-color);
        }
        
        #dataTable tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        
        .table-container {
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 15px;
            border: 1px solid var(--panel-border);
            border-radius: 4px;
        }
        
        .chart-container {
            position: relative;
            height: 300px;
            margin-top: 20px;
            background-color: white;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid var(--panel-border);
        }
        
        .select-columns {
            margin-top: 10px;
            margin-bottom: 15px;
        }
        
        .checkbox-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            background-color: white;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid var(--panel-border);
        }
        
        .checkbox-item {
            display: flex;
            align-items: center;
            margin-right: 10px;
        }
        
        input[type="checkbox"] {
            margin-right: 5px;
        }
        
        footer {
            text-align: center;
            margin-top: 30px;
            color: var(--text-muted);
            font-size: 12px;
            padding: 10px;
            border-top: 1px solid var(--panel-border);
        }
        
        .settings-row {
            display: flex;
            align-items: center;
            height: 100%;
            color: var(--header-text);
        }
        
        .settings-row label {
            margin-right: 5px;
            white-space: nowrap;
        }
        
        input[type="number"], select {
            padding: 6px;
            border: none;
            border-radius: 4px;
            height: 20px;
            background-color: rgba(255, 255, 255, 0.2);
            color: white;
        }
        
        #autoExport {
            width: 40px;
            text-align: center;
        }

        select {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--panel-border);
            border-radius: 4px;
            background-color: white;
            color: var(--text-color);
            height: auto;
        }
        
        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            overflow: auto;
        }
        
        .modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            max-width: 700px;
            position: relative;
        }
        
        .close-modal {
            position: absolute;
            top: 15px;
            right: 15px;
            font-size: 24px;
            cursor: pointer;
            color: var(--text-muted);
        }
        
        .close-modal:hover {
            color: var(--text-color);
        }
        
        .about-content {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .about-image {
            max-width: 100%;
            margin-bottom: 20px;
            border-radius: 8px;
        }
        
        .about-text {
            text-align: left;
            line-height: 1.6;
        }
        
        .about-text h2 {
            color: var(--primary-color);
            margin-top: 0;
        }
        
        .action-buttons {
            display: flex;
            gap: 10px;
        }
	
        #exportImageButton {
       		 background-color: rgba(255, 255, 255, 0.2);
        	 min-width: 100px;
    	}
    
    #exportImageButton:hover {
        background-color: rgba(255, 255, 255, 0.3);
    }
    
    #exportImageButton:disabled {
        background-color: rgba(255, 255, 255, 0.1);
        color: rgba(255, 255, 255, 0.5);
    }
    
    #exportImageButton:not(:disabled) {
        background-color: rgba(255, 255, 255, 0.85);
        color: var(--header-bg);
        font-weight: 500;
    }
    
    #exportImageButton:not(:disabled):hover {
        background-color: white;
    }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="logo-title">
                <img src="ChronoSenseFront.png" alt="ChronoSense Logo" class="logo">
                <div class="title-container">
                    <h1>ChronoSense</h1>
                    <!-- Instance name will be added here by JavaScript -->
                </div>
            </div>
            <div class="header-controls">
                <div class="control-box">
                    <button id="connectButton">
                        <div id="connectionIndicator" class="connection-indicator"></div>
                        Connect
                    </button>
                </div>
                <div class="export-controls">
                    <button id="exportButton" disabled>
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-download"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
                        Export
                    </button>
                    <div class="settings-row">
                        <label for="autoExport">Auto (min):</label>
                        <input type="number" id="autoExport" min="0" max="60" value="0">
                    </div>
                </div>
                <button id="aboutButton" title="About ChronoSense">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-info"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>
                </button>
            </div>
        </header>

        <div class="panel">
            <div class="panel-title">Data Collection</div>
            <div class="action-buttons">
                <button id="clearButton" disabled>
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-trash-2"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>
                    Clear Data
                </button>
            </div>
            <span id="dataCount">0 records collected</span>
            <div class="table-container">
                <table id="dataTable">
                    <thead>
                        <tr>
                            <th>Timestamp</th>
                            <!-- Column headers will be added dynamically based on incoming data -->
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Data rows will be added here -->
                    </tbody>
                </table>
            </div>
        </div>

        <div class="panel">
            <div class="panel-title">Visualise</div>
            <div class="select-columns">
                <label>Select columns to visualize:</label>
                <div id="columnSelectors" class="checkbox-group">
                    <!-- Column checkboxes will be added dynamically -->
                </div>
            </div>
            <div class="settings-row" style="height: auto; color: var(--text-color); margin: 10px 0;">
                <label for="timeWindow">Time window to display:</label>
                <select id="timeWindow">
                    <option value="all">All data</option>
                    <option value="1" selected>Last 1 minute</option>
                    <option value="5">Last 5 minutes</option>
                    <option value="15">Last 15 minutes</option>
                    <option value="60">Last hour</option>
                </select>
            </div>
            <div class="chart-container">
                <canvas id="dataChart"></canvas>
            </div>
        </div>

        <footer>
            <p>St. Mary's Edenderry 2025 | Version 1.0</p>
        </footer>
    </div>

    <!-- About Modal -->
    <div id="aboutModal" class="modal">
        <div class="modal-content">
            <span class="close-modal">&times;</span>
            <div class="about-content">
                <img src="AboutChronoSense.png" alt="About ChronoSense" class="about-image">
                <div class="about-text">
                    <h2>About ChronoSense</h2>
                    <p>ChronoSense is a data acquisition application tool designed in St Mary's Edenderry specifically for science and technology classrooms. It enables teachers and students to collect, visualize, and analyze data from Microbit devices paired with various sensors.</p>
                    
                    <p>The application was created to support hands-on STEM education across multiple disciplines including Physics, Chemistry, Biology, Agricultural Science, Applied Technology, and even Computer Science. 
                By combining affordable Microbit technology with accessible data collection tools, ChronoSense makes scientific experimentation more accessible to students.</p>
                    
                    <p>Features include:</p>
                    <ul>
                        <li>Real-time data collection from Microbit devices via serial USB connection</li>
                        <li>Dynamic support for any type and number of sensor data values</li>
                        <li>CSV export capabilities for further analysis in spreadsheet applications</li>
                        <li>Support for a wide range of sensor types and configurations</li>
                        <li>Automatic time-stamping of all collected data</li>
                    </ul>
                    
                    <p>ChronoSense is provided as a free resource for educational use and may be freely distributed to support classroom science projects.</p>
                    <p>The latest version can be downloaded at <a href="https://github.com/jamesdanedu/chronoSense">https://github.com/jamesdanedu/chronoSense</a> </p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Function to get and display instance information from URL parameters
        function getInstanceInfo() {
            const urlParams = new URLSearchParams(window.location.search);
            const instanceId = urlParams.get('instance') || '';
            const instanceName = urlParams.get('name') || '';
            
            // Only update UI if launched from launcher (has instance parameter)
            if (instanceId) {
                console.log("Instance detected:", instanceId, instanceName);
                
                // Update page title with instance name
                document.title = instanceName ? `ChronoSense - ${instanceName}` : 'ChronoSense';
                
                // Add the instance name to the header
                const titleContainer = document.querySelector('.title-container');
                if (titleContainer && instanceName) {
                    // Create a subtitle element for the instance name
                    const subtitle = document.createElement('div');
                    subtitle.className = 'instance-subtitle';
                    subtitle.textContent = instanceName;
                    
                    // Add it below the h1 element
                    titleContainer.appendChild(subtitle);
                    console.log("Added instance name to UI:", instanceName);
                }
            }
            
            // Return instance information for use elsewhere
            return { instanceId, instanceName };
        }

        // Call this function early to initialize instance info
        const instanceInfo = getInstanceInfo();
        const instanceId = instanceInfo.instanceId;
        const instanceName = instanceInfo.instanceName;
        
        // Global variables
        let port;
        let reader;
        let readLoopRunning = false;
        let allData = [];
        let dataColumns = [];
        let chart;
        let autoExportInterval;
        
        // DOM elements
        const connectButton = document.getElementById('connectButton');
        const connectionIndicator = document.getElementById('connectionIndicator');
        const exportButton = document.getElementById('exportButton');
        const clearButton = document.getElementById('clearButton');
        const dataTable = document.getElementById('dataTable');
        const dataCount = document.getElementById('dataCount');
        const columnSelectors = document.getElementById('columnSelectors');
        const autoExportInput = document.getElementById('autoExport');
        const timeWindowSelect = document.getElementById('timeWindow');
        const aboutButton = document.getElementById('aboutButton');
        const aboutModal = document.getElementById('aboutModal');
        const closeModal = document.querySelector('.close-modal');
        
        // Initialize Modal
        aboutButton.addEventListener('click', () => {
            aboutModal.style.display = 'block';
        });
        
        closeModal.addEventListener('click', () => {
            aboutModal.style.display = 'none';
        });
        
        window.addEventListener('click', (event) => {
            if (event.target === aboutModal) {
                aboutModal.style.display = 'none';
            }
        });

        // Function to make column header editable
        function makeHeaderEditable(th, columnIndex) {
            th.classList.add('editable');
            
            th.addEventListener('click', function() {
                // If already editing, return
                if (th.classList.contains('editing')) return;
                
                const originalText = th.textContent;
                th.classList.add('editing');
                
                // Create input field
                const input = document.createElement('input');
                input.type = 'text';
                input.value = originalText;
                
                // Clear the cell content and add the input
                th.textContent = '';
                th.appendChild(input);
                input.focus();
                
                // Handle input blur (finish editing)
                input.addEventListener('blur', finishEditing);
                
                // Handle Enter key
                input.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter') {
                        finishEditing();
                    }
                });
                
                function finishEditing() {
                    const newColumnName = input.value.trim() || originalText; // Fallback to original if empty
                    
                    // Update the header
                    th.textContent = newColumnName;
                    th.classList.remove('editing');
                    
                    // Update our data columns array
                    dataColumns[columnIndex] = newColumnName;
                    
                    // Update column selectors
                    updateColumnSelectors();
                    
                    // Update chart
                    updateChart();
                }
            });
        }
        
        // Initialize elements
        autoExportInput.disabled = true; // Disabled by default
        const settingsRow = autoExportInput.closest('.settings-row');
        if (settingsRow) {
            settingsRow.classList.add('disabled');
        }
        if ('serial' in navigator) {
            connectButton.addEventListener('click', toggleConnection);
            exportButton.addEventListener('click', () => exportData('csv'));
            clearButton.addEventListener('click', clearData);
            autoExportInput.addEventListener('change', setupAutoExport);
            timeWindowSelect.addEventListener('change', updateChart);
        } else {
            connectButton.disabled = true;
            connectButton.textContent = 'Web Serial API not supported';
            alert('Your browser does not support the Web Serial API. Please use Chrome or Edge.');
        }
        
        // Function to export chart as image
        function exportChartAsImage() {
            if (!chart) {
                alert('No chart available to export');
                return;
            }
            
            try {
                // Get the canvas element
                const canvas = document.getElementById('dataChart');
                
                // Create a white background (charts with transparency will otherwise have black background)
                const context = canvas.getContext('2d');
                const compositeOperation = context.globalCompositeOperation;
                const originalCanvasData = context.getImageData(0, 0, canvas.width, canvas.height);
                
                // Create a temporary offscreen canvas
                const offscreenCanvas = document.createElement('canvas');
                const offscreenContext = offscreenCanvas.getContext('2d');
                offscreenCanvas.width = canvas.width;
                offscreenCanvas.height = canvas.height;
                
                // Draw white background
                offscreenContext.fillStyle = 'white';
                offscreenContext.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw the original canvas on top
                offscreenContext.drawImage(canvas, 0, 0);
                
                // Restore the original canvas
                context.putImageData(originalCanvasData, 0, 0);
                context.globalCompositeOperation = compositeOperation;
                
                // Convert to image and trigger download
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                
                // Create instance-specific filename if available
                let exportFilename;
                if (instanceName) {
                    const sanitizedName = instanceName.toLowerCase().replace(/[^a-z0-9]+/g, '-');
                    exportFilename = `chronosense-chart-${sanitizedName}-${timestamp}.png`;
                } else {
                    exportFilename = `chronosense-chart-${timestamp}.png`;
                }
                
                const dataURL = offscreenCanvas.toDataURL('image/png');
                
                // Create download link
                const link = document.createElement('a');
                link.download = exportFilename;
                link.href = dataURL;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            } catch (error) {
                console.error('Error exporting chart:', error);
                alert('Failed to export chart as image. Check console for details.');
            }
        }

        // Add an export image button next to the existing export button
        function addExportImageButton() {
            const exportButton = document.getElementById('exportButton');
            if (exportButton) {
                const exportControlsDiv = exportButton.parentElement;
                
                // Create the export image button
                const exportImageButton = document.createElement('button');
                exportImageButton.id = 'exportImageButton';
                exportImageButton.disabled = true; // Start disabled like the CSV export button
                exportImageButton.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                        <circle cx="8.5" cy="8.5" r="1.5"></circle>
                        <polyline points="21 15 16 10 5 21"></polyline>
                    </svg>
                    Chart PNG
                `;
                
                // Add click event listener
                exportImageButton.addEventListener('click', exportChartAsImage);
                
                // Insert the button after the export button
                exportControlsDiv.insertBefore(exportImageButton, exportButton.nextSibling);
                
                // Update the toggleConnection function to enable/disable this button too
                const originalToggleConnection = toggleConnection;
                toggleConnection = async function() {
                    await originalToggleConnection.apply(this, arguments);
                    const exportImageButton = document.getElementById('exportImageButton');
                    if (exportImageButton) {
                        exportImageButton.disabled = exportButton.disabled;
                    }
                };
                
                // Also update the updateChart function to enable the export image button when there's data
                const originalUpdateChart = updateChart;
                updateChart = function() {
                    originalUpdateChart.apply(this, arguments);
                    const exportImageButton = document.getElementById('exportImageButton');
                    if (exportImageButton && chart && chart.data.datasets.length > 0 && chart.data.datasets[0].data.length > 0) {
                        exportImageButton.disabled = false;
                    }
                };
            }
        }

        // Run this function when the page loads
        addExportImageButton();

        // Initialize the chart
        function initChart() {
            const ctx = document.getElementById('dataChart').getContext('2d');
            
            // Clear existing chart if any
            if (chart) {
                chart.destroy();
            }
            
            chart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: []
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'minute',
                                displayFormats: {
                                    minute: 'HH:mm',
                                    hour: 'HH:mm'
                                }
                            },
                            title: {
                                display: true,
                                text: 'Time (HH:MM)'
                            }
                        },
                        y: {
                            beginAtZero: false,
                            title: {
                                display: true,
                                text: 'Value'
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            mode: 'index',
                            intersect: false
                        },
                        legend: {
                            position: 'top'
                        }
                    },
                    elements: {
                        point: {
                            radius: 3,
                            hoverRadius: 7
                        },
                        line: {
                            tension: 0.2
                        }
                    }
                }
            });
            
            console.log("Chart initialized with date adapter");
        }
        
        // Initialize chart on page load
        initChart();
        
        // Connect or disconnect from the serial port
        async function toggleConnection() {
            if (port) {
                // Disconnect
                if (reader) {
                    await reader.cancel();
                    readLoopRunning = false;
                    reader = null;
                }
                
                await port.close();
                port = null;
                
                connectButton.textContent = 'Connect';
                connectionIndicator.classList.remove('active');
                
                // Disable buttons
                exportButton.disabled = true;
                clearButton.disabled = true;
                
                // Disable auto-export input
                autoExportInput.disabled = true;
                const settingsRow = autoExportInput.closest('.settings-row');
                if (settingsRow) {
                    settingsRow.classList.add('disabled');
                    settingsRow.classList.remove('enabled');
                }
                
                // Stop auto-export if it's running
                if (autoExportInterval) {
                    clearInterval(autoExportInterval);
                    autoExportInterval = null;
                }
            } else {
                // Connect
                try {
                    port = await navigator.serial.requestPort();
                    const baudRate = 115200; // will work for majority of cases, so not configurable for now
                    
                    await port.open({ baudRate });
                    
                    connectButton.textContent = 'Disconnect';
                    connectionIndicator.classList.add('active');
                    
                    exportButton.disabled = false;
                    clearButton.disabled = false;
                    
                    // Enable auto-export input
                    autoExportInput.disabled = false;
                    const settingsRow = autoExportInput.closest('.settings-row');
                    if (settingsRow) {
                        settingsRow.classList.remove('disabled');
                        settingsRow.classList.add('enabled');
                    }
                    
                    // Set up auto-export if enabled
                    setupAutoExport();
                    
                    // Start reading data
                    readSerialData();
                    
                    // Try to restore data from local storage
                    tryRestoreData();
                } catch (error) {
                    console.error('Error connecting to serial port:', error);
                    alert('Failed to connect to the serial port. Please try again.');
                }
            }
        }
        
        // Read data from the serial port
        async function readSerialData() {
            if (!port) return;
            
            try {
                reader = port.readable.getReader();
                readLoopRunning = true;
                
                let buffer = '';
                const decoder = new TextDecoder();
                
                while (readLoopRunning) {
                    const { value, done } = await reader.read();
                    
                    if (done) {
                        reader.releaseLock();
                        break;
                    }
                    
                    // Decode the received bytes and add to buffer
                    const chunk = decoder.decode(value);
                    buffer += chunk;
                    
                    // Process complete lines in the buffer
                    const lines = buffer.split('\n');
                    buffer = lines.pop(); // Keep the incomplete line in the buffer
                    
                    for (const line of lines) {
                        if (line.trim()) {
                            processDataLine(line.trim());
                        }
                    }
                }
            } catch (error) {
                console.error('Error reading from serial port:', error);
                
                connectButton.textContent = 'Connect';
                connectionIndicator.classList.remove('active');
                
                if (reader) {
                    reader.releaseLock();
                }
            }
        }
        
        // Process a line of data from the serial port
        function processDataLine(line) {
            try {
                // Split the line by commas
                const values = line.split(',').map(v => v.trim());
                
                // If this is the first data or columns changed, update the table headers
                if (dataColumns.length === 0 || values.length !== dataColumns.length) {
                    updateDataColumns(values);
                }
                
                // Create a data object with timestamp and values
                const timestamp = new Date();
                const dataObj = {
                    timestamp: timestamp
                };
                
                values.forEach((value, index) => {
                    // Try to convert to number if possible
                    const numValue = parseFloat(value);
                    dataObj[dataColumns[index]] = isNaN(numValue) ? value : numValue;
                });
                
                // Add to our data array
                allData.push(dataObj);
                
                // Update the table with the new data
                addDataRow(dataObj);
                
                // Update the data count
                dataCount.textContent = `${allData.length} records collected`;
                
                // Update the chart
                updateChart();
                
                // Save to local storage periodically (every 10 records)
                if (allData.length % 10 === 0) {
                    saveToLocalStorage();
                }
            } catch (error) {
                console.error('Error processing data line:', error, line);
            }
        }
        
        // Update the data columns based on the first data line
        function updateDataColumns(values) {
            // Generate generic column names if not provided
            dataColumns = values.map((_, i) => `field${i+1}`);
            
            // Update the table headers
            const headerRow = dataTable.querySelector('thead tr');
            
            // Clear existing headers (except timestamp)
            while (headerRow.children.length > 1) {
                headerRow.removeChild(headerRow.lastChild);
            }
            
            // Add new headers
            dataColumns.forEach((column, index) => {
                const th = document.createElement('th');
                th.textContent = column;
                headerRow.appendChild(th);
                
                // Make the header editable
                makeHeaderEditable(th, index);
            });
            
            // Update column selectors for the chart
            updateColumnSelectors();
        }
        
        // Update column selectors for the chart
        function updateColumnSelectors() {
            // Clear existing checkboxes
            columnSelectors.innerHTML = '';
            
            // Add new checkboxes
            dataColumns.forEach((column, index) => {
                const div = document.createElement('div');
                div.className = 'checkbox-item';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `col-${index}`;
                checkbox.dataset.column = column;
                checkbox.checked = index === 0; // Select the first column by default
                checkbox.addEventListener('change', updateChart);
                
                const label = document.createElement('label');
                label.htmlFor = `col-${index}`;
                label.textContent = column;
                
                div.appendChild(checkbox);
                div.appendChild(label);
                columnSelectors.appendChild(div);
            });
            
            // Initialize chart datasets
            updateChartDatasets();
        }
        
        // Add a data row to the table
        function addDataRow(dataObj) {
            const tbody = dataTable.querySelector('tbody');
            const row = document.createElement('tr');
            
            // Add timestamp cell
            const timestampCell = document.createElement('td');
            timestampCell.textContent = dataObj.timestamp.toLocaleTimeString();
            row.appendChild(timestampCell);
            
            // Add data cells
            dataColumns.forEach(column => {
                const cell = document.createElement('td');
                cell.textContent = dataObj[column];
                row.appendChild(cell);
            });
            
            // Add to the top of the table
            tbody.insertBefore(row, tbody.firstChild);
            
            // Limit the number of rows displayed (for performance)
            if (tbody.children.length > 100) {
                tbody.removeChild(tbody.lastChild);
            }
        }
        
        // Update the chart with the current data
        function updateChart() {
            if (!chart || allData.length === 0) {
                console.log("Chart not initialized or no data available");
                return;
            }
            
            // Get selected columns
            const selectedColumns = Array.from(columnSelectors.querySelectorAll('input[type="checkbox"]:checked'))
                .map(cb => cb.dataset.column);
            
            console.log("Selected columns:", selectedColumns);
            
            // Filter data based on the selected time window
            const windowMinutes = parseInt(timeWindowSelect.value);
            const filteredData = windowMinutes === 'all' ? allData : allData.filter(d => {
                return (new Date() - d.timestamp) <= windowMinutes * 60 * 1000;
            });
            
            console.log("Filtered data count:", filteredData.length);
            console.log("Sample data point:", filteredData.length > 0 ? filteredData[0] : "No data");
            
            if (filteredData.length === 0) {
                console.log("No data after filtering by time window");
                return;
            }
            
            // Update datasets
            chart.data.datasets = selectedColumns.map((column, index) => {
                const colors = [
                    '#3182ce', '#38b2ac', '#e53e3e', '#ed8936', 
                    '#805ad5', '#38a169', '#d69e2e', '#4a5568'
                ];
                
                const dataPoints = filteredData.map(d => ({
                    x: d.timestamp,
                    y: d[column]
                }));
                
                console.log(`Dataset for ${column}:`, dataPoints.slice(0, 3)); // Show first 3 points
                console.log(`${column} min:`, Math.min(...dataPoints.map(p => p.y)));
                console.log(`${column} max:`, Math.max(...dataPoints.map(p => p.y)));
                
                return {
                    label: column,
                    data: dataPoints,
                    borderColor: colors[index % colors.length],
                    backgroundColor: colors[index % colors.length] + '20',
                    tension: 0.1,
                    borderWidth: 2,
                    pointRadius: 3, // Increased point size for visibility
                    pointHoverRadius: 7
                };
            });
            
            // If no datasets selected but we have data, show something by default
            if (chart.data.datasets.length === 0 && dataColumns.length > 0) {
                console.log("No columns selected, defaulting to first column:", dataColumns[0]);
                const colors = ['#3182ce'];
                
                const dataPoints = filteredData.map(d => ({
                    x: d.timestamp,
                    y: d[dataColumns[0]]
                }));
                
                chart.data.datasets = [{
                    label: dataColumns[0],
                    data: dataPoints,
                    borderColor: colors[0],
                    backgroundColor: colors[0] + '20',
                    tension: 0.1,
                    borderWidth: 2,
                    pointRadius: 3,
                    pointHoverRadius: 7
                }];
                
                // Check the first checkbox
                const firstCheckbox = document.getElementById('col-0');
                if (firstCheckbox) firstCheckbox.checked = true;
            }
            
            console.log("Chart datasets:", chart.data.datasets);
            chart.update();
            console.log("Chart updated");
        }
        
        // Initialize chart datasets
        function updateChartDatasets() {
            if (!chart) return;
            chart.data.datasets = [];
            chart.update();
            updateChart();
        }
        
        // Export data as CSV
        function exportData(format) {
            if (allData.length === 0) {
                alert('No data to export');
                return;
            }
            
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            
            // Create CSV header row with expanded timestamp columns
            const headers = [
                'timestamp',             // Original timestamp (ISO format)
                'date',                  // Date in DD-MM-YYYY format
                'time',                  // Time in HH:MM:SS format
                'day_of_week',           // Full day name (Monday, Tuesday, etc.)
                'month_of_year',         // Short month name (Jan, Feb, Mar, etc.)
                ...dataColumns
            ];
            
            const csvRows = [headers.join(',')];
            
            // Add data rows with expanded timestamp information
            allData.forEach(data => {
                const dt = new Date(data.timestamp);
                
                // Format date as DD-MM-YYYY
                const day = dt.getDate().toString().padStart(2, '0');
                const month = (dt.getMonth() + 1).toString().padStart(2, '0');
                const year = dt.getFullYear();
                const formattedDate = `${day}-${month}-${year}`;
                
                // Format time as HH:MM:SS
                const hours = dt.getHours().toString().padStart(2, '0');
                const minutes = dt.getMinutes().toString().padStart(2, '0');
                const seconds = dt.getSeconds().toString().padStart(2, '0');
                const formattedTime = `${hours}:${minutes}:${seconds}`;
                
                // Get day of week
                const daysOfWeek = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                const dayOfWeek = daysOfWeek[dt.getDay()];
                
                // Get month name
                const monthsOfYear = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                const monthOfYear = monthsOfYear[dt.getMonth()];
                
                // Prepare row with expanded timestamp data plus original data columns
                const row = [
                    data.timestamp.toISOString(),   // Original timestamp
                    formattedDate,                  // Date in DD-MM-YYYY
                    formattedTime,                  // Time in HH:MM:SS
                    dayOfWeek,                      // Day of week
                    monthOfYear,                    // Month of year
                    ...dataColumns.map(col => {
                        // Handle special characters for CSV (quote fields with commas, etc.)
                        let value = data[col];
                        if (value === null || value === undefined) {
                            return '';
                        }
                        
                        value = String(value);
                        
                        // If value contains commas, quotes, or newlines, wrap in quotes and escape internal quotes
                        if (value.includes(',') || value.includes('"') || value.includes('\n')) {
                            return '"' + value.replace(/"/g, '""') + '"';
                        }
                        
                        return value;
                    })
                ];
                
                csvRows.push(row.join(','));
            });
            
            const blob = new Blob([csvRows.join('\n')], { type: 'text/csv;charset=utf-8' });
            
            // Create instance-specific filename if available
            let exportFilename;
            if (instanceName) {
                const sanitizedName = instanceName.toLowerCase().replace(/[^a-z0-9]+/g, '-');
                exportFilename = `chronosense-data-${sanitizedName}-${timestamp}.csv`;
            } else {
                exportFilename = `chronosense-data-${timestamp}.csv`;
            }
            
            saveAs(blob, exportFilename);
        }
        
        // Setup auto-export interval
        function setupAutoExport() {
            const minutes = parseInt(autoExportInput.value);
            
            // Clear existing interval
            if (autoExportInterval) {
                clearInterval(autoExportInterval);
                autoExportInterval = null;
            }
            
            // Set up new interval if minutes > 0
            if (minutes > 0 && port) {
                autoExportInterval = setInterval(() => {
                    exportData('csv');
                }, minutes * 60 * 1000);
            }
        }
        
        // Clear all data
        function clearData() {
            if (confirm('Are you sure you want to clear all collected data?')) {
                allData = [];
                
                // Clear the table
                const tbody = dataTable.querySelector('tbody');
                tbody.innerHTML = '';
                
                // Update the data count
                dataCount.textContent = '0 records collected';
                
                // Update the chart
                updateChart();
                
                // Clear local storage
                // Use instance-specific key if available
                const storageKey = instanceId ? `microbitsensordata-${instanceId}` : 'microbitsensordata';
                localStorage.removeItem(storageKey);
            }
        }
        
        // Save data to local storage
        function saveToLocalStorage() {
            try {
                // Only save the last 1000 records to avoid localStorage limits
                const dataToSave = allData.slice(-1000);
                
                // Convert data for storage
                const serializedData = JSON.stringify({
                    timestamp: new Date().toISOString(),
                    columns: dataColumns,
                    data: dataToSave.map(d => ({
                        ...d,
                        timestamp: d.timestamp.toISOString()
                    }))
                });
                
                // Use instance-specific storage key if available
                const storageKey = instanceId ? `microbitsensordata-${instanceId}` : 'microbitsensordata';
                localStorage.setItem(storageKey, serializedData);
            } catch (e) {
                console.error('Error saving to localStorage:', e);
            }
        }
        
        // Try to restore data from local storage
        function tryRestoreData() {
            try {
                // Use instance-specific storage key if available
                const storageKey = instanceId ? `microbitsensordata-${instanceId}` : 'microbitsensordata';
                const savedData = localStorage.getItem(storageKey);
                if (!savedData) return;
                
                const { timestamp, columns, data } = JSON.parse(savedData);
                
                // Check if data is recent (less than 1 day old)
                const savedTime = new Date(timestamp);
                const now = new Date();
                const oneDay = 24 * 60 * 60 * 1000;
                
                if (now - savedTime > oneDay) {
                    // Data is old, don't restore
                    return;
                }
                
                // Ask user if they want to restore
                if (!confirm(`Found previous session data from ${savedTime.toLocaleString()}. Restore it?`)) {
                    return;
                }
                
                // Restore columns
                dataColumns = columns;
                
                // Update table headers
                const headerRow = dataTable.querySelector('thead tr');
                while (headerRow.children.length > 1) {
                    headerRow.removeChild(headerRow.lastChild);
                }
                
                dataColumns.forEach((column, index) => {
                    const th = document.createElement('th');
                    th.textContent = column;
                    headerRow.appendChild(th);
                    
                    // Make the header editable
                    makeHeaderEditable(th, index);
                });
                
                // Restore data
                allData = data.map(d => ({
                    ...d,
                    timestamp: new Date(d.timestamp)
                }));
                
                // Update the table
                const tbody = dataTable.querySelector('tbody');
                tbody.innerHTML = '';
                
                // Add the most recent 100 rows to the table
                allData.slice(-100).reverse().forEach(d => {
                    addDataRow(d);
                });
                
                // Update data count
                dataCount.textContent = `${allData.length} records collected`;
                
                // Update column selectors
                updateColumnSelectors();
                
                // Update chart
                updateChart();
            } catch (e) {
                console.error('Error restoring from localStorage:', e);
            }
        }
        
        // Add some test data if in development mode (for testing purposes)
        function addTestData() {
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.get('debug') === 'true') {
                dataColumns = ['Temperature', 'Humidity', 'Pressure'];
                
                // Update table headers
                const headerRow = dataTable.querySelector('thead tr');
                while (headerRow.children.length > 1) {
                    headerRow.removeChild(headerRow.lastChild);
                }
                
                dataColumns.forEach((column, index) => {
                    const th = document.createElement('th');
                    th.textContent = column;
                    headerRow.appendChild(th);
                    
                    // Make the header editable
                    makeHeaderEditable(th, index);
                });
                
                // Create test data
                const now = new Date();
                for (let i = 0; i < 20; i++) {
                    const timestamp = new Date(now.getTime() - (i * 5000)); // 5 second intervals
                    allData.push({
                        timestamp: timestamp,
                        Temperature: 20 + Math.random() * 5,
                        Humidity: 40 + Math.random() * 10,
                        Pressure: 1000 + Math.random() * 20
                    });
                }
                
                // Sort by timestamp (newest first for the table)
                allData.sort((a, b) => b.timestamp - a.timestamp);
                
                // Update the table
                const tbody = dataTable.querySelector('tbody');
                tbody.innerHTML = '';
                
                // Add the data to the table
                allData.forEach(d => {
                    addDataRow(d);
                });
                
                // Update data count
                dataCount.textContent = `${allData.length} records collected`;
                
                // Update column selectors
                updateColumnSelectors();
                
                // Enable export and clear buttons
                exportButton.disabled = false;
                clearButton.disabled = false;
                
                // Update chart
                updateChart();
            }
        }
        
        // Check if we should add test data
        addTestData();
        
        // Check for browser close and save data
        window.addEventListener('beforeunload', function() {
            saveToLocalStorage();
        });
    </script>
</body>
</html>
